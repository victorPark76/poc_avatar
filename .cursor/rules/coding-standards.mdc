# 코딩 표준 (Coding Standards)

> **이 문서는 프로젝트의 코드 품질과 일관성을 유지하기 위한 코딩 표준을 정의합니다.**

## 🎯 TypeScript 규칙

### **타입 정의**

- **인터페이스 우선**: 타입보다 인터페이스 사용
- **엄격 모드**: `strict: true` 설정 준수
- **명시적 타입**: 암시적 any 타입 금지

```typescript
// ✅ 좋은 예시
interface Character {
  id: string
  name: string
  level: number
}

// ❌ 피해야 할 예시
const character: any = { id: '1', name: '아서' }
```

### **타입 가드 활용**

```typescript
// 타입 가드 함수 정의
const isCharacter = (obj: unknown): obj is Character => {
  return typeof obj === 'object' && obj !== null && 'id' in obj && 'name' in obj
}

// 사용 예시
if (isCharacter(data)) {
  console.log(data.name) // 타입 안전
}
```

## ⚛️ React 규칙

### **컴포넌트 작성**

- **함수형 컴포넌트**: 클래스 컴포넌트 대신 함수형 사용
- **Props 인터페이스**: 명시적 타입 정의
- **단일 책임**: 하나의 컴포넌트는 하나의 역할만
- **React 19 권장 방식**: `React.FC` 대신 직접 타입 정의 사용, `use` 훅 활용

```typescript
// ✅ React 19 권장 방식 (가장 권장)
interface CharacterCardProps {
  character: Character
  onEdit?: (character: Character) => void
  onDelete?: (id: string) => void
}

const CharacterCard = ({ character, onEdit, onDelete }: CharacterCardProps) => {
  // 컴포넌트 로직
}

// ✅ React 19 use 훅 활용 (비동기 데이터 처리)
const CharacterCard = ({ characterId }: { characterId: string }) => {
  const character = use(characterService.getCharacter(characterId))

  return (
    <div>
      <h2>{character.name}</h2>
      {/* 컴포넌트 로직 */}
    </div>
  )
}

// ✅ 명시적 반환 타입 (필요시)
const CharacterCard = ({
  character,
  onEdit,
  onDelete,
}: CharacterCardProps): ReactElement => {
  // 컴포넌트 로직
}

// ✅ 함수 선언식 (복잡한 컴포넌트)
function CharacterCard({
  character,
  onEdit,
  onDelete,
}: CharacterCardProps): ReactElement {
  // 컴포넌트 로직
}

// ❌ React 19에서 권장하지 않는 방식
const CharacterCard: React.FC<CharacterCardProps> = ({
  character,
  onEdit,
  onDelete,
}) => {
  // 컴포넌트 로직
}
```

### **React.FC 사용 금지 이유**

- **children prop 자동 추가**: 의도하지 않은 children prop이 자동으로 추가됨
- **제네릭 호환성 문제**: 복잡한 타입과 함께 사용 시 타입 추론 문제
- **명시적 제어 부족**: 반환 타입과 props를 명확하게 제어할 수 없음
- **TypeScript 4.9+**: 더 나은 타입 추론을 위해 직접 타입 정의 권장
- **React 19 호환성**: 새로운 기능들과의 호환성 향상

### **반환 타입 권장사항 (React 19)**

- **타입 생략 권장**: TypeScript 자동 추론 활용 (가장 권장)
- **ReactElement 사용**: 명시적 타입이 필요한 경우
- **JSX.Element 사용 금지**: 너무 넓고 정확하지 않은 타입
- **ReactNode 고려**: null, undefined 등도 반환 가능한 경우
- **use 훅 활용**: 비동기 데이터 처리를 위한 새로운 패턴

### **React 19 새로운 기능 활용**

#### **use 훅 (Suspense 기반 데이터 페칭)**

```typescript
// ✅ React 19 use 훅 활용
const CharacterList = () => {
  const characters = use(characterService.getCharacters())

  return (
    <div>
      {characters.map(character => (
        <CharacterCard key={character.id} character={character} />
      ))}
    </div>
  )
}

// ✅ Promise를 직접 사용할 수 있음
const CharacterDetail = ({ characterId }: { characterId: string }) => {
  const character = use(characterService.getCharacter(characterId))
  const relatedCharacters = use(characterService.getRelatedCharacters(characterId))

  return (
    <div>
      <h1>{character.name}</h1>
      <RelatedCharacterList characters={relatedCharacters} />
    </div>
  )
}
```

#### **use 훅 사용 시 주의사항**

- **Suspense 경계**: use 훅을 사용하는 컴포넌트는 Suspense로 감싸야 함
- **에러 경계**: 에러 처리를 위해 ErrorBoundary 사용 권장
- **로딩 상태**: Suspense의 fallback으로 로딩 UI 처리
- **캐싱**: React Query와 함께 사용하여 데이터 캐싱 활용

```typescript
// ✅ 가장 권장 (타입 생략)
const Component = ({ title }: Props) => <div>{title}</div>

// ✅ 명시적 타입이 필요한 경우
const Component = ({ title }: Props): ReactElement => <div>{title}</div>

// ✅ 유연한 반환 타입이 필요한 경우
const Component = ({ title }: Props): ReactNode => {
  if (!title) return null
  return <div>{title}</div>
}

// ❌ 권장하지 않음
const Component = ({ title }: Props): JSX.Element => <div>{title}</div>
```

### **훅 사용 규칙**

- **최상단 배치**: 모든 훅은 컴포넌트 최상단에 배치
- **조건부 사용 금지**: if문이나 반복문 내에서 훅 사용 금지
- **의존성 배열**: useCallback, useMemo의 의존성 배열 정확히 명시

```typescript
// ✅ React 18 권장 방식
const CharacterManager = () => {
  // 훅은 최상단에 배치
  const [characters, setCharacters] = useState<Character[]>([])
  const { data, isLoading } = useQuery(['characters'], fetchCharacters)

  // 이벤트 핸들러
  const handleAdd = useCallback((character: Character) => {
    setCharacters(prev => [...prev, character])
  }, [])

  // JSX 반환
}
```

### **성능 최적화**

- **메모이제이션**: React.memo, useMemo, useCallback 적극 활용
- **불필요한 리렌더링 방지**: props 변경 시에만 리렌더링

```typescript
// 메모이제이션 예시
const MemoizedCharacterCard = React.memo(CharacterCard)

const handleEdit = useCallback((character: Character) => {
  // 편집 로직
}, []) // 의존성 배열 명시

const expensiveValue = useMemo(() => {
  return computeExpensiveValue(characters)
}, [characters]) // 의존성 배열 명시
```

## 🎨 스타일링 규칙

### **Tailwind CSS 우선**

- **유틸리티 클래스**: 커스텀 CSS보다 Tailwind 클래스 우선 사용
- **반응형 디자인**: `sm:`, `md:`, `lg:` 접두사 활용
- **일관된 스페이싱**: Tailwind의 기본 스페이싱 시스템 사용

```tsx
// ✅ 좋은 예시
<div className="w-full md:w-1/2 lg:w-1/3 p-4 bg-white rounded-lg shadow-md">
  <h2 className="text-xl font-bold text-gray-800 mb-4">제목</h2>
  <p className="text-gray-600 leading-relaxed">내용</p>
</div>

// ❌ 피해야 할 예시
<div style={{ width: '100%', padding: '16px', backgroundColor: 'white' }}>
```

### **Ant Design 컴포넌트**

- **기본 컴포넌트**: Ant Design의 기본 컴포넌트 우선 사용
- **테마 커스터마이징**: 프로젝트 브랜드에 맞게 테마 조정
- **접근성**: ARIA 속성과 키보드 네비게이션 고려

```tsx
// Ant Design 사용 예시
import { Button, Card, Input, Space } from 'antd'
;<Card className="character-card">
  <Space direction="vertical" size="middle" className="w-full">
    <Input placeholder="캐릭터 이름" />
    <Button type="primary" onClick={handleSave}>
      저장
    </Button>
  </Space>
</Card>
```

## 📁 파일 및 폴더 규칙

### **파일명 규칙**

- **컴포넌트**: PascalCase (예: `CharacterCard.tsx`)
- **훅**: camelCase + `use` 접두사 (예: `useCharacterData.ts`)
- **스토어**: camelCase + `Store` 접미사 (예: `characterStore.ts`)
- **서비스**: camelCase + `Service` 접미사 (예: `characterService.ts`)

### **폴더 구조**

```
src/
├── components/
│   ├── atoms/          # 기본 UI 요소
│   ├── molecules/      # 복합 컴포넌트
│   ├── organisms/      # 큰 단위 컴포넌트
│   └── layout/         # 레이아웃 컴포넌트
├── features/            # 기능별 모듈
├── hooks/               # 커스텀 훅
├── stores/              # 상태 관리
└── services/            # API 서비스
```

## 🔧 코드 품질 규칙

### **ESLint 규칙 준수**

- **자동 수정**: `pnpm lint --fix` 실행
- **규칙 위반 금지**: 린트 에러는 반드시 수정
- **일관된 스타일**: 팀 전체가 동일한 규칙 적용

### **Prettier 포맷팅**

- **자동 포맷팅**: 저장 시 자동 포맷팅 적용
- **일관된 스타일**: 들여쓰기, 줄바꿈 등 통일
- **설정 파일**: `.prettierrc` 설정 준수

### **주석 작성**

- **필요한 경우만**: 코드만으로 명확하지 않을 때만 작성
- **JSDoc 형식**: 함수와 인터페이스에 JSDoc 주석
- **영어 작성**: 주석은 영어로 작성

```typescript
/**
 * 캐릭터를 생성합니다.
 * @param data - 생성할 캐릭터 데이터
 * @returns 생성된 캐릭터 객체
 */
const createCharacter = async (
  data: CreateCharacterDto
): Promise<Character> => {
  // 구현 로직
}
```

## 🚀 성능 최적화 규칙

### **번들 최적화**

- **코드 스플리팅**: React.lazy와 Suspense 활용
- **동적 임포트**: 필요할 때만 모듈 로드
- **트리 쉐이킹**: 사용하지 않는 코드 제거

### **렌더링 최적화**

- **가상화**: 긴 목록의 경우 가상화 적용
- **지연 로딩**: 이미지와 무거운 컴포넌트 지연 로딩
- **메모이제이션**: 계산 비용이 높은 연산 메모이제이션

---

> **이 코딩 표준을 준수하여 일관성 있고 유지보수 가능한 코드를 작성합시다.**
> description:
> globs:

## alwaysApply: true
